#!/usr/bin/env python3
"""
Backend Stub Generator for ScratchRobin

This tool generates skeleton implementations for new database backend adapters.
It creates all necessary files following the established patterns and conventions.

Usage:
    python generate_backend.py --name <backend_name> [--output-dir <dir>]
    
Example:
    python generate_backend.py --name sqlite --output-dir ../../src/core
    
The generated files will include:
    - <backend>_backend.h / .cpp: Main backend adapter
    - <backend>_dialect.h / .cpp: SQL dialect implementation  
    - <backend>_metadata.h / .cpp: Metadata extraction
"""

import argparse
import os
import sys
from datetime import datetime
from string import Template

# =============================================================================
# Templates
# =============================================================================

HEADER_TEMPLATE = Template("""/**
 * @file ${backend_lower}_backend.h
 * @brief ${backend_name} database backend adapter
 * 
 * Auto-generated by stub_generator on ${date}
 * 
 * TODO: Implement the following methods:
 *   - ConnectImpl() - Establish database connection
 *   - DisconnectImpl() - Clean disconnection
 *   - ExecuteImpl() - Execute non-query SQL
 *   - QueryImpl() - Execute SELECT and return results
 *   - LoadSchemaImpl() - Introspect database schema
 *   - DetectCapabilitiesImpl() - Query backend capabilities
 *   - BeginTransactionImpl() - Start transaction
 *   - CommitImpl() - Commit transaction
 *   - RollbackImpl() - Rollback transaction
 */

#pragma once

#include "backend_adapter.h"
#include "connection_parameters.h"
#include "query_result.h"

#include <memory>
#include <string>
#include <vector>

// Forward declare ${backend_name} client library types
// TODO: Add actual includes based on ${backend_name} client library
struct ${backend_prefix}Connection;
struct ${backend_prefix}Result;

namespace scratchrobin {

/**
 * @brief ${backend_name} backend adapter implementation
 */
class ${backend_class} : public BackendAdapter {
public:
    ${backend_class}();
    ~${backend_class}() override;

    // Backend identification
    BackendType GetType() const override { return BackendType::${backend_enum}; }
    std::string GetName() const override { return "${backend_name}"; }
    std::string GetVersion() const override;

    // Connection management
    bool IsConnected() const override;
    
protected:
    // Core connection operations (implement these)
    bool ConnectImpl(const ConnectionParameters& params) override;
    void DisconnectImpl() override;
    
    // Query execution (implement these)
    bool ExecuteImpl(const std::string& sql, uint64_t& rowsAffected) override;
    std::unique_ptr<QueryResult> QueryImpl(const std::string& sql) override;
    
    // Schema introspection (implement this)
    std::unique_ptr<SchemaModel> LoadSchemaImpl(
        const std::optional<std::string>& schemaFilter,
        const std::optional<std::string>& tableFilter
    ) override;
    
    // Capability detection (implement this)
    void DetectCapabilitiesImpl(CapabilityInfo& caps) override;
    
    // Transaction support (implement these if supported)
    bool BeginTransactionImpl() override;
    bool CommitImpl() override;
    bool RollbackImpl() override;

private:
    // ${backend_name}-specific implementation details
    struct Impl;
    std::unique_ptr<Impl> pImpl_;
    
    // Helper methods (add as needed)
    std::string EscapeIdentifier(const std::string& identifier);
    std::string EscapeStringLiteral(const std::string& value);
    bool HandleError(const char* operation);
    
    // Conversion helpers
    DataType Map${backend_prefix}TypeToGeneric(int nativeType);
    int MapGenericTypeTo${backend_prefix}(DataType type);
    CellValue ConvertToCellValue(${backend_prefix}Result* result, int column);
};

} // namespace scratchrobin
""")

CPP_TEMPLATE = Template("""/**
 * @file ${backend_lower}_backend.cpp
 * @brief ${backend_name} database backend adapter implementation
 * 
 * Auto-generated by stub_generator on ${date}
 */

#include "${backend_lower}_backend.h"
#include "error_handler.h"
#include "value_formatter.h"

#include <sstream>
#include <cstring>

// TODO: Add ${backend_name} client library headers
// #include <${backend_lower}/lib${backend_lower}.h>

namespace scratchrobin {

// =============================================================================
// PImpl Structure
// =============================================================================

struct ${backend_class}::Impl {
    // TODO: Add ${backend_name} connection handle
    // ${backend_prefix}Connection* connection = nullptr;
    
    std::string serverVersion;
    bool connected = false;
    bool inTransaction = false;
    
    // Error state
    std::string lastError;
    int lastErrorCode = 0;
};

// =============================================================================
// Construction / Destruction
// =============================================================================

${backend_class}::${backend_class}()
    : pImpl_(std::make_unique<Impl>())
{
}

${backend_class}::~${backend_class}()
{
    if (IsConnected()) {
        DisconnectImpl();
    }
}

// =============================================================================
// Backend Information
// =============================================================================

std::string ${backend_class}::GetVersion() const
{
    return pImpl_->serverVersion;
}

bool ${backend_class}::IsConnected() const
{
    return pImpl_->connected;
}

// =============================================================================
// Connection Management (IMPLEMENT THESE)
// =============================================================================

bool ${backend_class}::ConnectImpl(const ConnectionParameters& params)
{
    // TODO: Implement connection logic
    // 1. Extract connection parameters (host, port, database, user, password)
    // 2. Initialize ${backend_name} client library
    // 3. Create connection
    // 4. Set connection options (timeout, encoding, etc.)
    // 5. Authenticate
    // 6. Query server version
    // 7. Set connected flag
    
    SetError("ConnectImpl not implemented");
    return false;
}

void ${backend_class}::DisconnectImpl()
{
    // TODO: Implement disconnection logic
    // 1. Rollback any open transaction
    // 2. Close connection handle
    // 3. Cleanup client library resources
    // 4. Clear connected flag
}

// =============================================================================
// Query Execution (IMPLEMENT THESE)
// =============================================================================

bool ${backend_class}::ExecuteImpl(const std::string& sql, uint64_t& rowsAffected)
{
    // TODO: Implement non-query execution
    // 1. Send SQL to server
    // 2. Check for errors
    // 3. Get rows affected count
    // 4. Return success/failure
    
    SetError("ExecuteImpl not implemented");
    return false;
}

std::unique_ptr<QueryResult> ${backend_class}::QueryImpl(const std::string& sql)
{
    // TODO: Implement query execution
    // 1. Send SQL to server
    // 2. Fetch result set metadata
    // 3. Fetch all rows
    // 4. Create and return QueryResult
    
    SetError("QueryImpl not implemented");
    return nullptr;
}

// =============================================================================
// Schema Introspection (IMPLEMENT THIS)
// =============================================================================

std::unique_ptr<SchemaModel> ${backend_class}::LoadSchemaImpl(
    const std::optional<std::string>& schemaFilter,
    const std::optional<std::string>& tableFilter)
{
    // TODO: Implement schema loading
    // 1. Query list of schemas (if supported)
    // 2. Query list of tables in filtered schemas
    // 3. For each table:
    //    - Query column definitions
    //    - Query primary keys
    //    - Query foreign keys
    //    - Query indexes
    //    - Query constraints
    // 4. Query additional objects (views, sequences, etc.)
    // 5. Build and return SchemaModel
    
    SetError("LoadSchemaImpl not implemented");
    return nullptr;
}

// =============================================================================
// Capability Detection (IMPLEMENT THIS)
// =============================================================================

void ${backend_class}::DetectCapabilitiesImpl(CapabilityInfo& caps)
{
    // TODO: Implement capability detection
    // Query or infer the following capabilities:
    
    caps.supportsTransactions = true;  // TODO: Detect
    caps.supportsSavepoints = false;   // TODO: Detect
    caps.supportsPreparedStatements = true;  // TODO: Detect
    caps.supportsStoredProcedures = false;   // TODO: Detect
    caps.supportsMultipleResultSets = false; // TODO: Detect
    caps.supportsBatchExecution = false;     // TODO: Detect
    caps.supportsScrollableCursors = false;  // TODO: Detect
    caps.supportsHoldableCursors = false;    // TODO: Detect
    caps.supportsPositionedUpdates = false;  // TODO: Detect
    caps.supportsNamedParameters = false;    // TODO: Detect
    caps.supportsLimitOffset = true;   // TODO: Detect (syntax varies)
    caps.supportsReturning = false;    // TODO: Detect
    caps.supportsUpsert = false;       // TODO: Detect
    caps.supportsWindowFunctions = false;    // TODO: Detect
    caps.supportsCommonTableExpressions = false; // TODO: Detect
    caps.supportsJson = false;         // TODO: Detect
    caps.supportsArrays = false;       // TODO: Detect
    caps.supportsFullTextSearch = false; // TODO: Detect
    caps.supportsSpatialTypes = false;   // TODO: Detect
    
    caps.maxConnections = 100;         // TODO: Query from server
    caps.maxStatementLength = 65535;   // TODO: Query from server
    caps.maxIdentifierLength = 64;     // TODO: Query from server
    caps.maxIndexKeys = 16;            // TODO: Query from server
    caps.maxRowSize = 65535;           // TODO: Query from server
    
    caps.sqlConformanceLevel = 1;      // TODO: Detect
    
    // TODO: Query supported aggregates
    // TODO: Query supported functions
    // TODO: Query supported data types
}

// =============================================================================
// Transaction Support (IMPLEMENT THESE)
// =============================================================================

bool ${backend_class}::BeginTransactionImpl()
{
    // TODO: Implement if transactions are supported
    // return ExecuteImpl("BEGIN", rows);
    SetError("Transactions not implemented");
    return false;
}

bool ${backend_class}::CommitImpl()
{
    // TODO: Implement if transactions are supported
    // return ExecuteImpl("COMMIT", rows);
    SetError("Transactions not implemented");
    return false;
}

bool ${backend_class}::RollbackImpl()
{
    // TODO: Implement if transactions are supported
    // return ExecuteImpl("ROLLBACK", rows);
    SetError("Transactions not implemented");
    return false;
}

// =============================================================================
// Helper Methods
// =============================================================================

std::string ${backend_class}::EscapeIdentifier(const std::string& identifier)
{
    // TODO: Implement identifier escaping for ${backend_name}
    // Example: "my table" -> \\"my table\\" (PostgreSQL style)
    //          "my table" -> `my table` (MySQL style)
    return identifier;
}

std::string ${backend_class}::EscapeStringLiteral(const std::string& value)
{
    // TODO: Implement string literal escaping
    // Handle quotes, backslashes, nulls, etc.
    return "'" + value + "'";
}

bool ${backend_class}::HandleError(const char* operation)
{
    // TODO: Get error info from ${backend_name} client library
    // SetError(...);
    // return false;
    return true;
}

DataType ${backend_class}::Map${backend_prefix}TypeToGeneric(int nativeType)
{
    // TODO: Map ${backend_name} native types to generic DataType enum
    // switch (nativeType) {
    //     case ${backend_prefix}_TYPE_INT: return DataType::Integer;
    //     ...
    // }
    return DataType::Text;
}

int ${backend_class}::MapGenericTypeTo${backend_prefix}(DataType type)
{
    // TODO: Map generic DataType to ${backend_name} native type
    // switch (type) {
    //     case DataType::Integer: return ${backend_prefix}_TYPE_INT;
    //     ...
    // }
    return 0;
}

CellValue ${backend_class}::ConvertToCellValue(${backend_prefix}Result* result, int column)
{
    // TODO: Convert ${backend_name} result cell to CellValue
    // Check for NULL
    // Get type
    // Convert based on type
    return CellValue();
}

} // namespace scratchrobin
""")

DIALECT_HEADER_TEMPLATE = Template("""/**
 * @file ${backend_lower}_dialect.h
 * @brief ${backend_name} SQL dialect implementation
 * 
 * Auto-generated by stub_generator on ${date}
 */

#pragma once

#include "sql_dialect.h"

namespace scratchrobin {

/**
 * @brief ${backend_name}-specific SQL dialect
 */
class ${dialect_class} : public SqlDialect {
public:
    ${dialect_class}();
    ~${dialect_class}() override = default;

    // Dialect identification
    std::string GetDialectName() const override { return "${backend_name}"; }
    
    // Identifier quoting
    std::string QuoteIdentifier(const std::string& identifier) const override;
    std::string QuoteStringLiteral(const std::string& value) const override;
    
    // Data type mappings
    std::string GetTypeName(DataType type, 
                           const std::optional<ColumnAttributes>& attrs) const override;
    std::optional<DataType> ParseTypeName(const std::string& name) const override;
    
    // SQL generation
    std::string CreateTableSql(const TableDef& table) const override;
    std::string DropTableSql(const std::string& schema, 
                            const std::string& name,
                            bool ifExists) const override;
    std::string AlterTableSql(const TableDef& original,
                             const TableChanges& changes) const override;
    std::string CreateIndexSql(const IndexDef& index) const override;
    std::string DropIndexSql(const std::string& schema,
                            const std::string& name,
                            bool ifExists) const override;
    
    // Pagination
    std::string LimitOffsetSql(const std::string& baseQuery,
                              std::optional<uint64_t> limit,
                              std::optional<uint64_t> offset) const override;
    
    // Features
    bool SupportsIfExists() const override { return ${supports_if_exists}; }
    bool SupportsIfNotExists() const override { return ${supports_if_not_exists}; }
    bool SupportsCascade() const override { return ${supports_cascade}; }
    bool SupportsReturnClause() const override { return ${supports_returning}; }
    bool SupportsUpsert() const override { return ${supports_upsert}; }
    uint32_t MaxIdentifierLength() const override { return ${max_id_length}; }

private:
    std::string GenerateColumnDef(const ColumnDef& column) const;
    std::string GenerateConstraintDef(const ConstraintDef& constraint) const;
    std::string GenerateIndexDef(const IndexDef& index) const;
};

} // namespace scratchrobin
""")

DIALECT_CPP_TEMPLATE = Template("""/**
 * @file ${backend_lower}_dialect.cpp
 * @brief ${backend_name} SQL dialect implementation
 * 
 * Auto-generated by stub_generator on ${date}
 */

#include "${backend_lower}_dialect.h"
#include "value_formatter.h"

#include <sstream>

namespace scratchrobin {

// =============================================================================
// Construction
// =============================================================================

${dialect_class}::${dialect_class}()
{
}

// =============================================================================
// Identifier Quoting (IMPLEMENT THESE)
// =============================================================================

std::string ${dialect_class}::QuoteIdentifier(const std::string& identifier) const
{
    // TODO: Implement identifier quoting for ${backend_name}
    // Example implementations:
    // PostgreSQL: return \\"" + EscapeQuotes(identifier, '\"') + \\"\\";
    // MySQL:      return "`" + EscapeBackticks(identifier) + "`";
    // SQL Server: return "[" + EscapeBrackets(identifier) + "]";
    return identifier;
}

std::string ${dialect_class}::QuoteStringLiteral(const std::string& value) const
{
    // TODO: Implement string literal quoting
    // Standard SQL uses single quotes, with doubling for escaping
    std::string result = "'";
    for (char c : value) {
        if (c == '\\'') {
            result += "''";
        } else {
            result += c;
        }
    }
    result += "'";
    return result;
}

// =============================================================================
// Data Type Mappings (IMPLEMENT THESE)
// =============================================================================

std::string ${dialect_class}::GetTypeName(DataType type,
                                         const std::optional<ColumnAttributes>& attrs) const
{
    // TODO: Map generic DataType to ${backend_name}-specific type name
    // Examples:
    switch (type) {
        case DataType::Boolean:
            return "BOOLEAN";
        case DataType::Integer:
            return "INTEGER";
        case DataType::BigInt:
            return "BIGINT";
        case DataType::Float:
            return "FLOAT";
        case DataType::Double:
            return "DOUBLE";
        case DataType::Decimal:
            if (attrs && attrs->precision.has_value()) {
                auto scale = attrs->scale.value_or(0);
                return "DECIMAL(" + std::to_string(attrs->precision.value()) + 
                       "," + std::to_string(scale) + ")";
            }
            return "DECIMAL";
        case DataType::VarChar:
            if (attrs && attrs->length.has_value()) {
                return "VARCHAR(" + std::to_string(attrs->length.value()) + ")";
            }
            return "VARCHAR";
        case DataType::Text:
            return "TEXT";
        case DataType::Blob:
            return "BLOB";
        case DataType::Date:
            return "DATE";
        case DataType::Time:
            return "TIME";
        case DataType::DateTime:
            return "DATETIME";
        case DataType::Timestamp:
            return "TIMESTAMP";
        case DataType::Json:
            return "JSON";
        case DataType::Uuid:
            return "UUID";
        default:
            return "TEXT";
    }
}

std::optional<DataType> ${dialect_class}::ParseTypeName(const std::string& name) const
{
    // TODO: Parse ${backend_name} type name and return generic DataType
    // Example: "VARCHAR(255)" -> DataType::VarChar
    //          "int4" -> DataType::Integer
    // Handle case-insensitivity
    return DataType::Text;
}

// =============================================================================
// SQL Generation (IMPLEMENT THESE)
// =============================================================================

std::string ${dialect_class}::CreateTableSql(const TableDef& table) const
{
    // TODO: Generate CREATE TABLE statement
    // 1. Handle IF NOT EXISTS if supported
    // 2. Generate column definitions
    // 3. Generate constraints (PK, FK, unique, check)
    // 4. Generate table-level options (engine, charset, etc.)
    
    std::ostringstream sql;
    sql << "CREATE TABLE ";
    
    if (!table.schema.empty()) {
        sql << QuoteIdentifier(table.schema) << ".";
    }
    sql << QuoteIdentifier(table.name) << " (\\n";
    
    // TODO: Add columns, constraints
    
    sql << ")";
    
    return sql.str();
}

std::string ${dialect_class}::DropTableSql(const std::string& schema,
                                          const std::string& name,
                                          bool ifExists) const
{
    // TODO: Generate DROP TABLE statement
    std::ostringstream sql;
    sql << "DROP TABLE ";
    if (ifExists && SupportsIfExists()) {
        sql << "IF EXISTS ";
    }
    if (!schema.empty()) {
        sql << QuoteIdentifier(schema) << ".";
    }
    sql << QuoteIdentifier(name);
    return sql.str();
}

std::string ${dialect_class}::AlterTableSql(const TableDef& original,
                                           const TableChanges& changes) const
{
    // TODO: Generate ALTER TABLE statement(s)
    // May need to generate multiple statements for complex changes
    // Handle limitations of ${backend_name} ALTER TABLE
    
    std::ostringstream sql;
    sql << "ALTER TABLE ";
    if (!original.schema.empty()) {
        sql << QuoteIdentifier(original.schema) << ".";
    }
    sql << QuoteIdentifier(original.name);
    
    // TODO: Add specific alter operations
    
    return sql.str();
}

std::string ${dialect_class}::CreateIndexSql(const IndexDef& index) const
{
    // TODO: Generate CREATE INDEX statement
    // Handle: UNIQUE, partial indexes, expression indexes, etc.
    
    std::ostringstream sql;
    sql << "CREATE ";
    if (index.unique) {
        sql << "UNIQUE ";
    }
    sql << "INDEX ";
    if (index.ifNotExists && SupportsIfNotExists()) {
        sql << "IF NOT EXISTS ";
    }
    sql << QuoteIdentifier(index.name);
    sql << " ON ";
    if (!index.schema.empty()) {
        sql << QuoteIdentifier(index.schema) << ".";
    }
    sql << QuoteIdentifier(index.table);
    sql << " (";
    
    // TODO: Add indexed columns with sort order
    
    sql << ")";
    
    return sql.str();
}

std::string ${dialect_class}::DropIndexSql(const std::string& schema,
                                          const std::string& name,
                                          bool ifExists) const
{
    // TODO: Generate DROP INDEX statement
    // Note: Some databases require table name in DROP INDEX
    
    std::ostringstream sql;
    sql << "DROP INDEX ";
    if (ifExists && SupportsIfExists()) {
        sql << "IF EXISTS ";
    }
    if (!schema.empty()) {
        sql << QuoteIdentifier(schema) << ".";
    }
    sql << QuoteIdentifier(name);
    return sql.str();
}

std::string ${dialect_class}::LimitOffsetSql(const std::string& baseQuery,
                                            std::optional<uint64_t> limit,
                                            std::optional<uint64_t> offset) const
{
    // TODO: Implement ${backend_name}-specific LIMIT/OFFSET syntax
    // PostgreSQL: LIMIT x OFFSET y
    // MySQL:      LIMIT y, x  or  LIMIT x OFFSET y
    // SQL Server: OFFSET y ROWS FETCH NEXT x ROWS ONLY
    // Oracle:     OFFSET y ROWS FETCH NEXT x ROWS ONLY
    
    std::ostringstream sql;
    sql << baseQuery;
    
    if (offset.has_value()) {
        sql << " OFFSET " << offset.value();
    }
    if (limit.has_value()) {
        sql << " LIMIT " << limit.value();
    }
    
    return sql.str();
}

// =============================================================================
// Helper Methods
// =============================================================================

std::string ${dialect_class}::GenerateColumnDef(const ColumnDef& column) const
{
    // TODO: Generate column definition for CREATE TABLE
    // Include: name, type, constraints (NOT NULL, DEFAULT, etc.)
    
    std::ostringstream sql;
    sql << QuoteIdentifier(column.name) << " ";
    sql << GetTypeName(column.type, column.attributes);
    
    // TODO: Add constraints
    // if (!column.nullable) sql << " NOT NULL";
    // if (column.defaultValue) sql << " DEFAULT " << *column.defaultValue;
    // if (column.primaryKey) sql << " PRIMARY KEY";
    // if (column.unique) sql << " UNIQUE";
    
    return sql.str();
}

std::string ${dialect_class}::GenerateConstraintDef(const ConstraintDef& constraint) const
{
    // TODO: Generate table constraint definition
    // Handle: PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK
    return "";
}

std::string ${dialect_class}::GenerateIndexDef(const IndexDef& index) const
{
    // TODO: Generate inline index definition (for CREATE TABLE)
    // Some databases support inline index definitions
    return "";
}

} // namespace scratchrobin
""")

# =============================================================================
# Generator Functions
# =============================================================================

def to_camel_case(name: str) -> str:
    """Convert snake_case or kebab-case to CamelCase."""
    parts = name.replace('-', '_').split('_')
    return ''.join(p.capitalize() for p in parts)

def to_enum_case(name: str) -> str:
    """Convert to UPPER_SNAKE_CASE for enums."""
    parts = name.replace('-', '_').split('_')
    return '_'.join(p.upper() for p in parts)

def generate_backend(name: str, output_dir: str) -> None:
    """Generate backend adapter stub files."""
    
    # Generate template variables
    backend_lower = name.lower().replace('-', '_')
    backend_prefix = to_camel_case(name)
    backend_class = backend_prefix + "Backend"
    dialect_class = backend_prefix + "Dialect"
    
    # Default capability flags (should be customized)
    dialect_vars = {
        'backend_lower': backend_lower,
        'backend_name': name,
        'backend_prefix': backend_prefix,
        'backend_class': backend_class,
        'dialect_class': dialect_class,
        'backend_enum': to_enum_case(name),
        'date': datetime.now().strftime('%Y-%m-%d'),
        'supports_if_exists': 'true',
        'supports_if_not_exists': 'true',
        'supports_cascade': 'true',
        'supports_returning': 'false',
        'supports_upsert': 'false',
        'max_id_length': '64'
    }
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    files_generated = []
    
    # Generate backend header
    header_path = os.path.join(output_dir, f"{backend_lower}_backend.h")
    with open(header_path, 'w') as f:
        f.write(HEADER_TEMPLATE.safe_substitute(dialect_vars))
    files_generated.append(header_path)
    
    # Generate backend implementation
    cpp_path = os.path.join(output_dir, f"{backend_lower}_backend.cpp")
    with open(cpp_path, 'w') as f:
        f.write(CPP_TEMPLATE.safe_substitute(dialect_vars))
    files_generated.append(cpp_path)
    
    # Generate dialect header
    dialect_h_path = os.path.join(output_dir, f"{backend_lower}_dialect.h")
    with open(dialect_h_path, 'w') as f:
        f.write(DIALECT_HEADER_TEMPLATE.safe_substitute(dialect_vars))
    files_generated.append(dialect_h_path)
    
    # Generate dialect implementation
    dialect_cpp_path = os.path.join(output_dir, f"{backend_lower}_dialect.cpp")
    with open(dialect_cpp_path, 'w') as f:
        f.write(DIALECT_CPP_TEMPLATE.safe_substitute(dialect_vars))
    files_generated.append(dialect_cpp_path)
    
    return files_generated

def main():
    parser = argparse.ArgumentParser(
        description='Generate backend adapter stub files for ScratchRobin',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s --name sqlite
    %(prog)s --name oracle --output-dir ../../src/core
    %(prog)s --name mssql --output-dir /path/to/output
        """
    )
    
    parser.add_argument('--name', required=True,
                       help='Backend name (e.g., sqlite, oracle, mssql)')
    parser.add_argument('--output-dir', default='.',
                       help='Output directory for generated files (default: current dir)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Print what would be generated without creating files')
    
    args = parser.parse_args()
    
    # Validate backend name
    if not args.name.replace('-', '_').replace(' ', '_').isalnum():
        print(f"Error: Invalid backend name '{args.name}'", file=sys.stderr)
        sys.exit(1)
    
    # Generate files
    if args.dry_run:
        print(f"Would generate backend adapter files for '{args.name}':")
        backend_lower = args.name.lower().replace('-', '_')
        files = [
            f"{backend_lower}_backend.h",
            f"{backend_lower}_backend.cpp",
            f"{backend_lower}_dialect.h", 
            f"{backend_lower}_dialect.cpp"
        ]
        for f in files:
            print(f"  - {os.path.join(args.output_dir, f)}")
    else:
        files = generate_backend(args.name, args.output_dir)
        print(f"Generated backend adapter for '{args.name}':")
        for f in files:
            print(f"  - {f}")
        print()
        print("Next steps:")
        print(f"  1. Add {to_camel_case(args.name)}Backend to BackendType enum")
        print(f"  2. Add client library to CMakeLists.txt")
        print(f"  3. Implement the TODO sections in each file")
        print(f"  4. Add tests in tests/integration/")

if __name__ == '__main__':
    main()
