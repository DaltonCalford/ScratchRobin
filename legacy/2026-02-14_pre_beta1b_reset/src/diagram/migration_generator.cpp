/*
 * ScratchRobin
 * Copyright (c) 2025-2026 Dalton Calford
 *
 * Licensed under the Initial Developer's Public License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * https://www.firebirdsql.org/en/initial-developer-s-public-license-version-1-0/
 */
#include "migration_generator.h"

#include "ui/diagram_model.h"

#include <algorithm>
#include <sstream>

namespace scratchrobin {
namespace diagram {

std::vector<MigrationOperation> MigrationGenerator::GenerateMigration(
    const DiagramModel& current_model,
    const DiagramModel& target_model,
    const std::string& dialect) {
    
    std::vector<MigrationOperation> operations;
    
    const auto& current_nodes = current_model.nodes();
    const auto& target_nodes = target_model.nodes();
    
    // Find tables to create (in target but not in current)
    for (const auto& target_node : target_nodes) {
        auto it = std::find_if(current_nodes.begin(), current_nodes.end(),
            [&target_node](const DiagramNode& n) { return n.name == target_node.name; });
        
        if (it == current_nodes.end()) {
            MigrationOperation op;
            op.type = MigrationOperationType::CreateTable;
            op.table_name = target_node.name;
            op.sql = GenerateCreateTableSql(target_node, dialect);
            operations.push_back(op);
        } else {
            // Table exists - check for column changes
            for (const auto& target_attr : target_node.attributes) {
                auto attr_it = std::find_if(it->attributes.begin(), it->attributes.end(),
                    [&target_attr](const DiagramAttribute& a) { return a.name == target_attr.name; });
                
                if (attr_it == it->attributes.end()) {
                    // Column to add
                    MigrationOperation op;
                    op.type = MigrationOperationType::AddColumn;
                    op.table_name = target_node.name;
                    op.object_name = target_attr.name;
                    op.new_definition = target_attr.data_type;
                    op.sql = GenerateAddColumnSql(target_node.name, target_attr, dialect);
                    operations.push_back(op);
                } else if (attr_it->data_type != target_attr.data_type) {
                    // Column to alter
                    MigrationOperation op;
                    op.type = MigrationOperationType::AlterColumn;
                    op.table_name = target_node.name;
                    op.object_name = target_attr.name;
                    op.old_definition = attr_it->data_type;
                    op.new_definition = target_attr.data_type;
                    op.sql = GenerateAlterColumnSql(target_node.name, target_attr.name,
                                                     target_attr.data_type, dialect);
                    operations.push_back(op);
                }
            }
            
            // Check for columns to drop
            for (const auto& current_attr : it->attributes) {
                auto attr_it = std::find_if(target_node.attributes.begin(), target_node.attributes.end(),
                    [&current_attr](const DiagramAttribute& a) { return a.name == current_attr.name; });
                
                if (attr_it == target_node.attributes.end()) {
                    MigrationOperation op;
                    op.type = MigrationOperationType::DropColumn;
                    op.table_name = target_node.name;
                    op.object_name = current_attr.name;
                    op.sql = GenerateDropColumnSql(target_node.name, current_attr.name, dialect);
                    operations.push_back(op);
                }
            }
        }
    }
    
    // Find tables to drop (in current but not in target)
    for (const auto& current_node : current_nodes) {
        auto it = std::find_if(target_nodes.begin(), target_nodes.end(),
            [&current_node](const DiagramNode& n) { return n.name == current_node.name; });
        
        if (it == target_nodes.end()) {
            MigrationOperation op;
            op.type = MigrationOperationType::DropTable;
            op.table_name = current_node.name;
            op.sql = GenerateDropTableSql(current_node.name, dialect);
            operations.push_back(op);
        }
    }
    
    return operations;
}

std::string MigrationGenerator::GenerateSqlScript(
    const std::vector<MigrationOperation>& operations,
    const std::string& dialect) {
    
    std::ostringstream script;
    
    script << "-- Migration script generated by ScratchRobin\n";
    script << "-- Target dialect: " << dialect << "\n\n";
    script << "BEGIN;\n\n";
    
    for (const auto& op : operations) {
        script << "-- " << op.table_name;
        if (!op.object_name.empty()) {
            script << "." << op.object_name;
        }
        script << "\n";
        script << op.sql << "\n\n";
    }
    
    script << "COMMIT;\n";
    
    return script.str();
}

MigrationGenerator::MigrationScripts MigrationGenerator::GenerateFullMigration(
    const DiagramModel& database_model,
    const DiagramModel& diagram_model,
    const std::string& dialect) {
    
    MigrationScripts scripts;
    
    // Upgrade: database -> diagram
    auto upgrade_ops = GenerateMigration(database_model, diagram_model, dialect);
    scripts.upgrade_script = GenerateSqlScript(upgrade_ops, dialect);
    
    // Downgrade: diagram -> database
    auto downgrade_ops = GenerateMigration(diagram_model, database_model, dialect);
    scripts.downgrade_script = GenerateSqlScript(downgrade_ops, dialect);
    
    // Add warnings for destructive operations
    for (const auto& op : downgrade_ops) {
        if (op.type == MigrationOperationType::DropTable) {
            scripts.warnings.push_back("Will drop table: " + op.table_name);
        } else if (op.type == MigrationOperationType::DropColumn) {
            scripts.warnings.push_back("Will drop column: " + op.table_name + "." + op.object_name);
        }
    }
    
    return scripts;
}

std::string MigrationGenerator::GenerateCreateTableSql(const DiagramNode& node,
                                                        const std::string& dialect) {
    std::ostringstream sql;
    
    sql << "CREATE TABLE " << QuoteIdentifier(node.name, dialect) << " (\n";
    
    for (size_t i = 0; i < node.attributes.size(); ++i) {
        const auto& attr = node.attributes[i];
        sql << "    " << QuoteIdentifier(attr.name, dialect) << " "
            << MapDataType(attr.data_type, dialect);
        
        if (attr.is_primary) {
            sql << " PRIMARY KEY";
        }
        
        if (i < node.attributes.size() - 1) {
            sql << ",";
        }
        sql << "\n";
    }
    
    sql << ");";
    
    return sql.str();
}

std::string MigrationGenerator::GenerateAlterTableSql(const MigrationOperation& op,
                                                       const std::string& dialect) {
    return "-- Alter table operation not implemented";
}

std::string MigrationGenerator::GenerateDropTableSql(const std::string& table_name,
                                                      const std::string& dialect) {
    return "DROP TABLE " + QuoteIdentifier(table_name, dialect) + ";";
}

std::string MigrationGenerator::GenerateAddColumnSql(const std::string& table,
                                                      const DiagramAttribute& attr,
                                                      const std::string& dialect) {
    return "ALTER TABLE " + QuoteIdentifier(table, dialect) + " ADD COLUMN " +
           QuoteIdentifier(attr.name, dialect) + " " +
           MapDataType(attr.data_type, dialect) + ";";
}

std::string MigrationGenerator::GenerateDropColumnSql(const std::string& table,
                                                       const std::string& column,
                                                       const std::string& dialect) {
    return "ALTER TABLE " + QuoteIdentifier(table, dialect) + " DROP COLUMN " +
           QuoteIdentifier(column, dialect) + ";";
}

std::string MigrationGenerator::GenerateAlterColumnSql(const std::string& table,
                                                        const std::string& column,
                                                        const std::string& new_type,
                                                        const std::string& dialect) {
    if (dialect == "postgresql") {
        return "ALTER TABLE " + QuoteIdentifier(table, dialect) + " ALTER COLUMN " +
               QuoteIdentifier(column, dialect) + " TYPE " +
               MapDataType(new_type, dialect) + ";";
    } else if (dialect == "mysql") {
        return "ALTER TABLE " + QuoteIdentifier(table, dialect) + " MODIFY COLUMN " +
               QuoteIdentifier(column, dialect) + " " +
               MapDataType(new_type, dialect) + ";";
    } else {
        return "ALTER TABLE " + QuoteIdentifier(table, dialect) + " ALTER COLUMN " +
               QuoteIdentifier(column, dialect) + " " +
               MapDataType(new_type, dialect) + ";";
    }
}

std::string MigrationGenerator::QuoteIdentifier(const std::string& name,
                                                 const std::string& dialect) {
    // Most SQL dialects use double quotes
    if (dialect == "mysql") {
        return "`" + name + "`";
    }
    return "\"" + name + "\"";
}

std::string MigrationGenerator::MapDataType(const std::string& type,
                                             const std::string& dialect) {
    // Simple type mapping - in production would be more comprehensive
    if (dialect == "postgresql") {
        if (type == "INT") return "INTEGER";
        if (type == "VARCHAR") return "VARCHAR(255)";
        if (type == "TEXT") return "TEXT";
        if (type == "DATETIME") return "TIMESTAMP";
    } else if (dialect == "mysql") {
        if (type == "INT") return "INT";
        if (type == "VARCHAR") return "VARCHAR(255)";
        if (type == "TEXT") return "TEXT";
        if (type == "DATETIME") return "DATETIME";
    }
    return type;
}

} // namespace diagram
} // namespace scratchrobin
